Wine model of development:

suppose there are 10k or APIs
suppose there are 10k or so applications, and each app needs some random subset of them
then suppose we "make them work" one at a time

Then plot percentage of applications working vs APIs done.  You should get something like a logistic curve

Ways to make more sophisticated:
model applications as being more likely to need some APIs than others.  Perhaps APIs should be normally distributed in terms of "probability of need"
"cluster" APIs as if I have A, then I 90% need B too. (sort of like direct3d 10.  this is largely similar to just making one bug very likely)
model some (random) APIs as "hard" (eg take more time to finish).  This changes our X axis from "APIs done" to "time"
model users as having some random number of multiple applications, and then not "happy" till they all work.  Then we can graph % happy users as well.
add new users, new apps, and new APIs over time (to simulate "moving target" and production of new applications)
--also change applications some existing users have, perhaps favoring newer ones
model some bugs as "not critical to happiness" -- ie if not solved, happiness only decreases a bit, or user only has a chance of being unhappy (eg bugs that don't affect everyone)
model changing development speed (bugs per day)

Goal is to test different strategies:
+ work on bugs randomly - not a bad model of a "default" strategy of just implementing APIs
+ pick a bug from a random application - slightly better as it ensures we have an actual application showing this bug
+ target "popular" bugs first -- just do the most commonly used ones (max collateral damage), somewhat unrealistic in that Wine devs won't always know which bug is affecting many apps (though often they do)
+ target applications that "almost" work - ie, find applications that need the least work done, and then do that (max specific damage)
+ target a single application and complete it
+ target most popular applications first
+ target easy bugs first (max bugs/days)
+ target a random app of a random user (responding to a bug report?)
+ some combination of these (eg volunteers working randomly, codeweavers doing the almost happy strategy, some devs doing the popular strategy)

A realistic model would have some percentage of this happening automatically, then the remaining 20% or so we can choose our strategy

Not implemented: 
 "dirty fixes", ie solutions to bugs that increase the time to perfection (perhaps by adding new bugs or more difficulty to existing bugs).  These might be thought of as ugly hacks to the code that somehow manage to get an app working, which in Wine's case Alexandre opposes.
 A strategy that would target "almost happy", ie the easiest to satisfy users, first.  

Best strategy has the greatest integral of happy * time (all strategies reach "perfect", ie all bugs solved, at the same rate)
Strategies will take different curves.  I suspect most will look like a logistic curve, and many will be effectively the same for large portions of it.


A good guess at # of bugs / time:
our current devlopment rate has about x patches every 2 weeks.  If Wine will be "done" (compatible with all current apps) in 4 years the this is 4*x*26 more to go, and roughly 20*x*26 total commits total.  If we assume a typical commit had to be worked on 10 times or so...


TODO:
+ apps should be a dictionary (key app number, value bugs he needs)
difficulty should be a dictionary (key app number, value days of work) ...note that value here could be a function too.  God python is cool.
users should be a dictionary (key user number, value apps he wants)
code for most popular app and most popular user could be...the same...
code for difficulty and best could be shared too...
